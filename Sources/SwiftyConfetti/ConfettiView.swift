
#if canImport(UIKit) && canImport(QuartzCore)

import QuartzCore
import UIKit

public class ConfettiView: UIView {
    public var config = ConfettiConfig()

    public lazy var emitter: CAEmitterLayer = {
        let emitter = CAEmitterLayer()
        emitter.emitterPosition = CGPoint(x: bounds.midX, y: 0)
        emitter.emitterSize = CGSize(width: bounds.size.width, height: 1)
        emitter.emitterShape = .rectangle
        emitter.frame = bounds
        return emitter
    }()

    public var isEmitting: Bool {
        emitter.birthRate != 0
    }

    public var emitterWidthMultiplier: CGFloat = 0.9

    override public init(frame: CGRect) {
        super.init(frame: frame)
        sharedInit()
    }

    public required init?(coder: NSCoder) {
        super.init(coder: coder)
        sharedInit()
    }

    private func sharedInit() {
        emitter.birthRate = 0
        reloadEmitter()
    }

    override public func layoutSubviews() {
        super.layoutSubviews()
        updateEmitterLayout()
    }

    private func updateEmitterLayout() {
        emitter.frame = bounds
        emitter.emitterPosition = CGPoint(x: bounds.midX, y: -500)
        emitter.emitterSize = CGSize(width: bounds.size.width, height: 500)
    }

    /// The confetti generator.
    /// Override this for custom generation.
    /// - Returns: The generator.
    open func generator() -> ConfettiGenerator {
        ConfettiGenerator(config: config)
    }

    /// Reloads the emitter by recreating the CAEmitterLayer and updating its properties.
    /// This method creates a new CAEmitterLayer and configures it with the updated emitter position, shape, size, and cells generated by the `generator`. The new emitter layer is then added as a sublayer to the view's layer.
    /// Call this method whenever you need to update the emitter configuration or regenerate the emitter cells.
    /// - Note: This method does not start or stop the emission of confetti particles. It only reloads the emitter with the updated configuration.
    /// - Warning: Make sure to call this method on the main thread to avoid potential synchronization issues with UIKit.
    /// - Precondition: The `generator` property must be properly configured before calling this method to ensure the emitter cells are correctly generated.
    private func reloadEmitter() {
        emitter = CAEmitterLayer()
        emitter.emitterPosition = CGPoint(x: frame.size.width / 2.0, y: 0)
        emitter.emitterShape = CAEmitterLayerEmitterShape.line
        emitter.emitterSize = CGSize(width: frame.size.width, height: 1)
        emitter.emitterCells = generator().generateCells()
        layer.addSublayer(emitter)
    }

    /// Starts emitting confetti particles with the specified rate, delay, and duration.
    /// Use this method to begin the emission of confetti particles with the desired rate, delay, and duration. The method first stops any ongoing emission by calling `stopConfetti()`. Then it reloads the emitter configuration by calling `reloadEmitter()`. After the specified delay, the emitter's birth rate is set to the provided rate to start emitting confetti particles.
    /// If a `stopAfter` duration is specified and greater than zero, the emission will automatically stop after the specified duration has passed, in addition to the specified delay.
    /// - Parameters:
    ///   - rate: The birth rate of the emitter. This determines the rate at which confetti particles are emitted per second. Default is 1.
    ///   - delay: The delay before the confetti starts, in seconds. Default is 0.
    ///   - stopAfter: The duration after which the confetti will automatically stop, in seconds. Default is 5. Set to a value less than or equal to 0 for infinite confetti.
    /// - Note: The method schedules the emission and automatic stopping on the main thread to ensure proper synchronization with UIKit.
    /// - Precondition: The `reloadEmitter()` method should be called before using this method to ensure the emitter is properly configured.
    public func startConfetti(
        rate: Float = 1,
        delay: TimeInterval = 0,
        stopAfter: TimeInterval = 5
    ) {
        stopConfetti()

        reloadEmitter()

        DispatchQueue.main.asyncAfter(deadline: .now()+delay) {
            self.emitter.birthRate = rate
        }

        if stopAfter > 0 {
            DispatchQueue.main.asyncAfter(deadline: .now()+stopAfter+delay) {
                self.emitter.birthRate = 0
            }
        }
    }

    /// Stops any new confetti from being generated.
    public func stopConfetti() {
        emitter.birthRate = 0
    }
}

#endif
